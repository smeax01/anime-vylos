---
import Layout from "../../layouts/Layout.astro";
import { getAnimeById } from "../../lib/anilist";
import { ArrowLeft, Play, Tv, Share2, Info } from "lucide-astro";

export const prerender = false;

const { id } = Astro.params;
const animeId = Number(id);

let anime = null;
try {
  anime = await getAnimeById(animeId);
} catch (e) {}

if (!anime) return Astro.redirect("/404");

const title = anime.title.romaji || anime.title.english;
const cover = anime.bannerImage || anime.coverImage.extraLarge;
---

<Layout title={title}>
  <div class="vylos-stream-page">
    <!-- Navbar Retour -->
    <div class="stream-nav">
      <a href="/" class="circle-back"><ArrowLeft size={24} /></a>
      <div class="anime-mini-info">
        <span class="mini-title">{title}</span>
        <span class="mini-status" id="mini-ep-display">Épisode 1</span>
      </div>
    </div>

    <!-- ZONE LECTEUR (INSPIRÉE ANIME-SAMA) -->
    <div class="main-player-section">
      <div class="player-viewport">
        <!-- Overlay d'attente -->
        <div id="player-loading" class="player-overlay">
          <div class="vylos-loader"></div>
          <p id="status-text">Synchronisation avec les serveurs...</p>
          <button id="manual-play" class="btn-primary hidden"
            >Lancer manuellement</button
          >
        </div>

        <!-- LE LECTEUR (IFRAME PROPRE) -->
        <iframe
          id="content-frame"
          class="stream-iframe"
          src="about:blank"
          allowfullscreen
          sandbox="allow-forms allow-pointer-lock allow-same-origin allow-scripts allow-top-navigation"
          allow="autoplay; encrypted-media"
        >
        </iframe>
      </div>

      <!-- BARRE DE SELECTION DE SOURCE (L'ASPIRATEUR) -->
      <div class="player-toolbar">
        <div class="server-selector">
          <span class="toolbar-label">LECTEURS :</span>
          <div class="server-chips">
            <button class="chip active" data-provider="gogo">Lecteur 1</button>
            <button class="chip" data-provider="zoro">Lecteur 2</button>
            <button class="chip" data-provider="alternative">Lecteur 3</button>
          </div>
        </div>
        <div class="player-actions">
          <button class="action-btn" id="reload-player">Rafraîchir</button>
        </div>
      </div>
    </div>

    <!-- CONTENU SOUS LE LECTEUR -->
    <div class="container stream-content">
      <div class="content-header">
        <div class="title-area">
          <h1>{title}</h1>
          <div class="badges">
            <span class="badge score"
              >★ {anime.averageScore ? anime.averageScore / 10 : "?"}</span
            >
            <span class="badge year">{anime.format}</span>
            <span class="badge lang">VOSTFR</span>
          </div>
        </div>
      </div>

      <div class="stream-grid">
        <!-- Liste des épisodes (Carrés compacts) -->
        <div class="episodes-column">
          <h3 class="section-title"><Tv size={20} /> Épisodes</h3>
          <div class="ep-selector-grid" id="ep-list">
            <!-- Injecté par JS -->
          </div>
        </div>

        <!-- Infos & Saisons -->
        <div class="details-column">
          <h3 class="section-title"><Info size={20} /> À propos</h3>
          <p class="description" set:html={anime.description} />

          {
            anime.relations?.edges?.length > 0 && (
              <div class="seasons-area">
                <h3 class="section-title">Saisons</h3>
                <div class="seasons-stack">
                  {anime.relations.edges
                    .filter((e) => e.node.type === "ANIME")
                    .map((rel) => (
                      <a href={`/anime/${rel.node.id}`} class="season-link">
                        <img src={rel.node.coverImage.medium} alt="" />
                        <div class="season-info">
                          <span class="rel-tag">{rel.relationType}</span>
                          <span class="rel-name">{rel.node.title.romaji}</span>
                        </div>
                      </a>
                    ))}
                </div>
              </div>
            )
          }
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  const frame = document.getElementById("content-frame") as HTMLIFrameElement;
  const loader = document.getElementById("player-loading");
  const statusText = document.getElementById("status-text");
  const epList = document.getElementById("ep-list");
  const miniEp = document.getElementById("mini-ep-display");
  const serverChips = document.querySelectorAll(".chip");
  const reloadBtn = document.getElementById("reload-player");

  const animeId = "{anime.id}";
  const animeTitle = "{title}";
  const totalEps = Number("{anime.episodes || 12}");

  let currentEp = 1;
  let currentProvider = "gogo";
  let episodesData: any[] = [];

  // Initialisation
  async function start() {
    try {
      statusText!.innerText = "Récupération des données...";
      const res = await fetch(
        `https://api-consumet.vercel.app/meta/anilist/info/${animeId}`
      );
      const data = await res.json();

      if (data.episodes && data.episodes.length > 0) {
        episodesData = data.episodes;
      } else {
        generateManual();
      }
    } catch (e) {
      generateManual();
    }
    renderEps();
    loadStream(episodesData[0]); // Auto-load first ep
  }

  function generateManual() {
    for (let i = 1; i <= (totalEps || 12); i++) {
      episodesData.push({ id: `manual-${i}`, number: i });
    }
  }

  function renderEps() {
    epList!.innerHTML = "";
    episodesData.forEach((ep) => {
      const btn = document.createElement("button");
      btn.className = `ep-chip ${ep.number === currentEp ? "active" : ""}`;
      btn.innerText = ep.number;
      btn.onclick = () => {
        document
          .querySelectorAll(".ep-chip")
          .forEach((c) => c.classList.remove("active"));
        btn.classList.add("active");
        loadStream(ep);
      };
      epList!.appendChild(btn);
    });
  }

  async function loadStream(ep: any) {
    currentEp = ep.number;
    miniEp!.innerText = `Épisode ${ep.number}`;
    loader!.style.display = "flex";
    statusText!.innerText = "Aspiration du lecteur...";
    frame.src = "about:blank";

    const slug = animeTitle.toLowerCase().replace(/[^a-z0-9]/g, "-");

    try {
      // On cherche l'Embed URL (Comme Anime-Sama)
      // On utilise GogoAnime ou Zoro comme base d'extraction
      const provider = currentProvider === "gogo" ? "gogoanime" : "zoro";
      const searchRes = await fetch(
        `https://api-consumet.vercel.app/anime/${provider}/${encodeURIComponent(slug)}`
      );
      const searchData = await searchRes.json();

      if (searchData.results && searchData.results.length > 0) {
        const watchRes = await fetch(
          `https://api-consumet.vercel.app/anime/${provider}/watch/${searchData.results[0].id}-episode-${ep.number}`
        );
        const watchData = await watchRes.json();

        if (watchData.headers?.Referer || watchData.sources?.[0]?.url) {
          // C'est ICI qu'on injecte l'embed pur
          // On privilégie le Referer qui est souvent l'iframe originale
          frame.src = watchData.headers?.Referer || watchData.sources[0].url;
          loader!.style.display = "none";
        } else {
          throw new Error();
        }
      } else {
        throw new Error();
      }
    } catch (e) {
      // Fallback Anime-Sama / Gogo 直接
      frame.src = `https://anitaku.to/embed/${slug}-episode-${ep.number}`;
      setTimeout(() => {
        loader!.style.display = "none";
      }, 2000);
    }
  }

  // Changement de serveur
  serverChips.forEach((chip) => {
    chip.addEventListener("click", () => {
      serverChips.forEach((c) => c.classList.remove("active"));
      chip.classList.add("active");
      currentProvider = (chip as HTMLElement).dataset.provider!;
      const ep = episodesData.find((e) => e.number === currentEp);
      loadStream(ep);
    });
  });

  reloadBtn!.onclick = () => {
    const ep = episodesData.find((e) => e.number === currentEp);
    loadStream(ep);
  };

  start();
</script>

<style>
  .hidden {
    display: none !important;
  }
  .vylos-stream-page {
    min-height: 100vh;
    background: #020617;
  }

  /* NAV */
  .stream-nav {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    padding: 1rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 1rem;
    background: linear-gradient(to bottom, rgba(2, 6, 23, 0.8), transparent);
  }
  .circle-back {
    width: 40px;
    height: 40px;
    background: rgba(59, 130, 246, 0.2);
    border: 1px solid rgba(59, 130, 246, 0.3);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    backdrop-filter: blur(10px);
  }
  .anime-mini-info {
    display: flex;
    flex-direction: column;
  }
  .mini-title {
    font-weight: 800;
    color: white;
    font-size: 0.9rem;
  }
  .mini-status {
    font-size: 0.7rem;
    color: var(--color-primary);
    font-weight: 700;
    text-transform: uppercase;
  }

  /* PLAYER */
  .main-player-section {
    background: #000;
    padding-top: 60px;
  }
  .player-viewport {
    width: 100%;
    aspect-ratio: 16/9;
    max-width: 1280px;
    margin: 0 auto;
    position: relative;
    background: #000;
    box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  }
  .stream-iframe {
    width: 100%;
    height: 100%;
    border: none;
  }

  .player-overlay {
    position: absolute;
    inset: 0;
    background: #000;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1.5rem;
    color: white;
  }
  .vylos-loader {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(59, 130, 246, 0.1);
    border-top-color: var(--color-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .player-toolbar {
    max-width: 1280px;
    margin: 0 auto;
    background: #0f172a;
    padding: 0.75rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }
  .server-selector {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .toolbar-label {
    font-size: 0.7rem;
    font-weight: 900;
    color: #64748b;
    letter-spacing: 1px;
  }
  .server-chips {
    display: flex;
    gap: 0.5rem;
  }
  .chip {
    background: #1e293b;
    color: #94a3b8;
    border: none;
    padding: 0.4rem 1rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
    cursor: pointer;
    transition: 0.2s;
  }
  .chip.active {
    background: var(--color-primary);
    color: white;
  }
  .action-btn {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #94a3b8;
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    font-size: 0.75rem;
    cursor: pointer;
  }

  /* CONTENT */
  .stream-content {
    padding-top: 3rem;
  }
  .content-header {
    margin-bottom: 2rem;
  }
  .content-header h1 {
    font-size: 2.2rem;
    font-weight: 900;
    margin-bottom: 1rem;
  }
  .badges {
    display: flex;
    gap: 0.5rem;
  }
  .badge {
    padding: 4px 12px;
    background: #1e293b;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
    color: #94a3b8;
  }
  .badge.score {
    color: #fbbf24;
    background: rgba(251, 191, 36, 0.1);
  }
  .badge.lang {
    color: var(--color-accent);
    background: rgba(56, 189, 248, 0.1);
  }

  .stream-grid {
    display: grid;
    grid-template-columns: 1fr 350px;
    gap: 3rem;
  }
  @media (max-width: 1024px) {
    .stream-grid {
      grid-template-columns: 1fr;
    }
  }

  .section-title {
    font-size: 1.1rem;
    font-weight: 900;
    color: white;
    margin-bottom: 1.5rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* EP SELECTOR */
  .ep-selector-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
    gap: 8px;
  }
  .ep-chip {
    aspect-ratio: 1;
    background: #1e293b;
    border: 1px solid rgba(255, 255, 255, 0.05);
    color: white;
    border-radius: 6px;
    font-weight: 800;
    cursor: pointer;
    transition: 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .ep-chip:hover {
    border-color: var(--color-primary);
    transform: scale(1.1);
  }
  .ep-chip.active {
    background: var(--color-primary);
    box-shadow: 0 0 15px rgba(59, 130, 246, 0.4);
  }

  .description {
    color: #94a3b8;
    line-height: 1.7;
    font-size: 0.95rem;
    margin-bottom: 3rem;
  }

  /* SEASONS */
  .seasons-stack {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  .season-link {
    display: flex;
    gap: 1rem;
    text-decoration: none;
    background: #0f172a;
    padding: 0.5rem;
    border-radius: 8px;
    border: 1px solid transparent;
    transition: 0.2s;
  }
  .season-link:hover {
    border-color: var(--color-primary);
    background: #1e293b;
  }
  .season-link img {
    width: 50px;
    height: 70px;
    object-fit: cover;
    border-radius: 4px;
  }
  .rel-tag {
    font-size: 0.6rem;
    color: var(--color-primary);
    font-weight: 900;
    text-transform: uppercase;
    display: block;
  }
  .rel-name {
    font-size: 0.8rem;
    color: white;
    font-weight: 600;
  }
</style>
