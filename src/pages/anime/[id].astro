---
import Layout from "../../layouts/Layout.astro";
import { getAnimeById } from "../../lib/anilist";
import {
  ArrowLeft,
  Play,
  Tv,
  Info,
  AlertCircle,
  RefreshCw,
  Heart,
  Settings,
  Globe,
} from "lucide-astro";

export const prerender = false;

const { id } = Astro.params;
const animeId = Number(id);

if (isNaN(animeId)) return Astro.redirect("/404");

let anime = null;
try {
  anime = await getAnimeById(animeId);
} catch (e) {
  console.error("AniList Fetch Error:", e);
}

if (!anime) return Astro.redirect("/404");

const title = anime.title.romaji || anime.title.english;
const cover = anime.bannerImage || anime.coverImage.extraLarge;
---

<Layout title={title}>
  <!-- Pass server data to client safely -->
  <div
    id="anime-data"
    data-id={anime.id}
    data-title={title}
    data-cover={anime.coverImage.large}
    data-type={`${anime.format || "TV"} • ${anime.genres[0] || "Anime"}`}
    data-eps={anime.episodes || 0}
    class="hidden"
  >
  </div>

  <div class="vylos-stream-page">
    <div class="stream-nav">
      <a href="/" class="circle-back"><ArrowLeft size={24} /></a>
      <div class="anime-mini-info">
        <span class="mini-title">{title}</span>
        <span class="mini-status" id="mini-ep-display">Chargement...</span>
      </div>
      <div class="nav-actions">
        <button id="toggle-favorite" class="icon-btn">
          <Heart id="fav-icon" size={24} />
        </button>
      </div>
    </div>

    <div class="main-player-section">
      <div class="player-viewport">
        <div id="player-loading" class="player-overlay">
          <div class="vylos-loader"></div>
          <p id="status-text">Recherche sur Anime-Sama...</p>
        </div>

        <iframe
          id="content-frame"
          class="stream-iframe"
          src="about:blank"
          allowfullscreen
          allow="autoplay; encrypted-media"
        >
        </iframe>
      </div>

      <div class="player-toolbar">
        <div class="toolbar-left">
          <div class="lang-selector">
            <button class="lang-btn" data-lang="vostfr">VOSTFR</button>
            <button class="lang-btn active" data-lang="vf">VF</button>
          </div>
          <div class="server-selector">
            <span class="toolbar-label">Miroir :</span>
            <div class="server-chips" id="as-servers">
              <!-- Boutons injectés ici -->
            </div>
          </div>
        </div>
        <div class="toolbar-right">
          <button class="action-btn" id="reload-player">
            <RefreshCw size={14} /> Actualiser
          </button>
        </div>
      </div>
    </div>

    <div class="container stream-content">
      <div class="stream-layout">
        <div class="main-col">
          <div class="title-area">
            <h1 class="anime-title">{title}</h1>
            <div class="badges">
              <span class="badge score"
                >★ {anime.averageScore ? anime.averageScore / 10 : "?"}</span
              >
              <span class="badge status">{anime.status}</span>
            </div>
          </div>

          <div class="episodes-section">
            <div class="section-header">
              <h3 class="section-title"><Tv size={20} /> Liste des Épisodes</h3>
              <div id="progress-indicator" class="progress-badge"></div>
            </div>
            <div class="ep-selector-grid" id="ep-list">
              <!-- Épisodes injectés ici -->
            </div>
          </div>

          <div id="error-box" class="hidden error-box">
            <AlertCircle size={24} />
            <div>
              <strong
                >Cette version (VOSTFR/VF) n'est pas disponible pour cet anime.</strong
              ><br />
              <small
                >Essayez de changer la langue ou vérifiez un autre anime.</small
              >
            </div>
          </div>
        </div>

        <div class="side-col">
          <h3 class="section-title"><Info size={20} /> Synopsis</h3>
          <p class="description" set:html={anime.description} />

          {
            anime.relations?.edges && anime.relations.edges.length > 0 && (
              <div class="seasons-area">
                <h3 class="section-title">Relations</h3>
                <div class="seasons-stack">
                  {anime.relations.edges
                    .filter((e: any) => e.node.type === "ANIME")
                    .map((rel: any) => (
                      <a href={`/anime/${rel.node.id}`} class="season-link">
                        <img src={rel.node.coverImage.medium} alt="" />
                        <div class="season-info">
                          <span class="rel-tag">{rel.relationType}</span>
                          <span class="rel-name">{rel.node.title.romaji}</span>
                        </div>
                      </a>
                    ))}
                </div>
              </div>
            )
          }
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  // DOM Elements
  const dataEl = document.getElementById("anime-data");
  const frame = document.getElementById("content-frame") as HTMLIFrameElement;
  const loader = document.getElementById("player-loading");
  const statusText = document.getElementById("status-text");
  const epList = document.getElementById("ep-list");
  const serverBox = document.getElementById("as-servers");
  const miniEp = document.getElementById("mini-ep-display");
  const errorBox = document.getElementById("error-box");
  const favBtn = document.getElementById("toggle-favorite");
  const favIcon = document.getElementById("fav-icon");
  const langBtns = document.querySelectorAll(".lang-btn");
  const progressBadge = document.getElementById("progress-indicator");

  const animeId = dataEl?.dataset.id || "";
  const animeTitle = dataEl?.dataset.title || "";
  const animeCover = dataEl?.dataset.cover || "";
  const animeType = dataEl?.dataset.type || "";

  let currentSources: any = {};
  let currentEp = 1;
  let activeServer = "eps3"; // Default: Sibnet
  let activeLang = "vf"; // Default: VF

  // --- LOCAL STORAGE LOGIC ---
  function getProgress() {
    const data = localStorage.getItem(`vylos_progress_${animeId}`);
    return data ? JSON.parse(data) : { lastEp: 1, history: [] };
  }

  async function saveProgress(ep: number) {
    const progress = getProgress();
    const isNewEpisode = !progress.history.includes(ep);

    progress.lastEp = ep;
    if (isNewEpisode) progress.history.push(ep);
    localStorage.setItem(`vylos_progress_${animeId}`, JSON.stringify(progress));

    // Update Global History (LocalStorage)
    const globalHistory = JSON.parse(
      localStorage.getItem("vylos_global_history") || "[]"
    );
    const existingIndex = globalHistory.findIndex(
      (a: any) => a.id === animeId.toString()
    );
    const animeEntry = {
      id: animeId.toString(),
      title: animeTitle,
      image: animeCover,
      type: animeType,
      lastEp: ep,
      updatedAt: Date.now(),
    };

    if (existingIndex > -1) globalHistory.splice(existingIndex, 1);
    globalHistory.unshift(animeEntry);
    localStorage.setItem(
      "vylos_global_history",
      JSON.stringify(globalHistory.slice(0, 20))
    );

    // Sync with Database if logged in
    const sessionStr = localStorage.getItem("vylos_session");
    if (sessionStr) {
      const user = JSON.parse(sessionStr);

      // Update DB history
      fetch("/api/sync", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "sync-history",
          userId: user.id,
          animeId: animeId.toString(),
          lastEp: ep,
          progressJson: JSON.stringify(progress),
        }),
      }).catch((e) => console.error("History sync failed", e));

      if (isNewEpisode) {
        user.stats.episodesSeen += 1;
        localStorage.setItem("vylos_session", JSON.stringify(user));

        // Update DB User Entry (episodes count)
        fetch("/api/auth", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            action: "update-stats",
            userId: user.id,
            episodesSeen: user.stats.episodesSeen,
          }),
        }).catch((e) => console.error("Stats update failed", e));
      }
    }

    updateUIProgress();
  }

  async function toggleFavorite() {
    const favorites = JSON.parse(
      localStorage.getItem("vylos_favorites") || "[]"
    );
    const index = favorites.findIndex(
      (fav: any) => fav.id === animeId.toString()
    );
    const sessionStr = localStorage.getItem("vylos_session");
    const user = sessionStr ? JSON.parse(sessionStr) : null;
    let isFavorite = false;

    if (index > -1) {
      favorites.splice(index, 1);
      favIcon?.classList.remove("active");
    } else {
      isFavorite = true;
      favorites.push({
        id: animeId.toString(),
        title: animeTitle,
        image: animeCover,
        type: animeType,
      });
      favIcon?.classList.add("active");
    }
    localStorage.setItem("vylos_favorites", JSON.stringify(favorites));

    // Sync with DB
    if (user) {
      fetch("/api/sync", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          action: "sync-favorite",
          userId: user.id,
          isFavorite,
          animeId: animeId.toString(),
          title: animeTitle,
          image: animeCover,
          type: animeType,
        }),
      }).catch((e) => console.error("Favorite sync failed", e));
    }
  }

  function updateUIProgress() {
    const progress = getProgress();
    const history = progress.history;
    document.querySelectorAll(".ep-chip").forEach((chip: any) => {
      const epNum = parseInt(chip.dataset.num);
      if (history.includes(epNum)) chip.classList.add("watched");
    });
    if (progressBadge) {
      progressBadge.innerText = `${history.length} épisodes vus`;
    }
  }

  function checkFavorite() {
    const favorites = JSON.parse(
      localStorage.getItem("vylos_favorites") || "[]"
    );
    if (favorites.some((fav: any) => fav.id === animeId.toString())) {
      favIcon?.classList.add("active");
    }
  }

  // --- ANIME-SAMA LOGIC ---
  function getSlugs(title: string) {
    const base = title
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
    const clean = base
      .replace(/[^a-z0-9]/g, "-")
      .replace(/-+/g, "-")
      .replace(/^-|-$/g, "");
    return [clean];
  }

  // --- API ---
  async function switchLang(lang: string) {
    activeLang = lang;
    langBtns.forEach((b) => {
      b.classList.toggle("active", b.getAttribute("data-lang") === lang);
    });

    statusText!.innerText = `Chargement des sources ${lang.toUpperCase()}...`;
    loader!.style.display = "flex";
    errorBox!.classList.add("hidden");

    const sources = await searchAnimeSama(lang);

    if (sources) {
      currentSources = sources;
      // Preference: Sibnet (eps3) > Previous Server > First available
      const lastServer = getProgress().server;
      activeServer = currentSources[lastServer]
        ? lastServer
        : currentSources.eps3
          ? "eps3"
          : Object.keys(currentSources)[0];

      renderServers();
      renderEpisodes();
      loadVideo(currentEp);
    } else {
      loader!.style.display = "none";
      errorBox!.classList.remove("hidden");
      statusText!.innerText = `Aucune source trouvée en ${lang.toUpperCase()} pour cet animé.`;
    }
  }

  async function searchAnimeSama(lang: string) {
    const slugs = getSlugs(animeTitle);
    for (const slug of slugs) {
      try {
        const res = await fetch(`/api/as-source?slug=${slug}&lang=${lang}`);
        if (!res.ok) continue;
        const data = await res.json();
        if (data.sources && Object.keys(data.sources).length > 0)
          return data.sources;
      } catch (e) {}
    }
    return null;
  }

  function renderServers() {
    serverBox!.innerHTML = "";
    const nameMap: any = {
      eps1: "Principal",
      eps2: "Flash",
      eps3: "Sibnet (Best)",
      eps4: "Sendvid",
    };

    Object.keys(currentSources)
      .sort()
      .forEach((key) => {
        if (currentSources[key].length === 0) return;
        const btn = document.createElement("button");
        btn.className = `chip ${key === activeServer ? "active" : ""}`;
        btn.innerText = nameMap[key] || `Source ${key}`;
        btn.onclick = () => {
          activeServer = key;
          renderServers();
          loadVideo(currentEp);
          saveProgress(currentEp); // Save server choice
        };
        serverBox!.appendChild(btn);
      });
  }

  function renderEpisodes() {
    epList!.innerHTML = "";
    const episodes = currentSources[activeServer] || [];
    episodes.forEach((url: string, index: number) => {
      const num = index + 1;
      const btn = document.createElement("button");
      btn.className = `ep-chip ${num === currentEp ? "active" : ""}`;
      btn.innerText = num.toString();
      btn.dataset.num = num.toString();
      btn.onclick = () => loadVideo(num);
      epList!.appendChild(btn);
    });
    updateUIProgress();
  }

  function loadVideo(num: number) {
    currentEp = num;
    miniEp!.innerText = `${activeLang.toUpperCase()} • Épisode ${num}`;
    loader!.style.display = "flex";

    const episodes = currentSources[activeServer] || [];
    const url = episodes[num - 1];

    if (url) {
      frame.src = url;
      saveProgress(num);

      document
        .querySelectorAll(".ep-chip")
        .forEach((c) => c.classList.remove("active"));
      const activeChip = document.querySelector(`.ep-chip[data-num="${num}"]`);
      if (activeChip) activeChip.classList.add("active");

      setTimeout(() => {
        loader!.style.display = "none";
      }, 1000);
    } else {
      statusText!.innerText = "Épisode non disponible sur ce serveur.";
      loader!.style.display = "none";
    }
  }

  // --- INIT ---
  async function init() {
    checkFavorite();

    // Check URL params first, then localStorage
    const params = new URLSearchParams(window.location.search);
    const saved = getProgress();

    currentEp = Number(params.get("ep")) || saved.lastEp || 1;
    const startLang = params.get("lang") || saved.lang || "vostfr";
    activeServer = saved.server || "eps3";

    await switchLang(startLang);
  }

  favBtn?.addEventListener("click", toggleFavorite);
  langBtns.forEach((btn) => {
    btn.addEventListener("click", () => {
      const lang = btn.getAttribute("data-lang");
      if (lang && lang !== activeLang) {
        // currentEp = 1; // Reset ep if switching lang manually? No, keep it.
        switchLang(lang);
      }
    });
  });

  document.getElementById("reload-player")!.onclick = () =>
    loadVideo(currentEp);

  init();
</script>

<style>
  .hidden {
    display: none !important;
  }
  .vylos-stream-page {
    min-height: 100vh;
    background: #020617;
    color: white;
  }

  .stream-nav {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    padding: 1rem 1.5rem;
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 1rem;
    background: linear-gradient(to bottom, rgba(2, 6, 23, 0.95), transparent);
  }

  .circle-back {
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    transition: 0.2s;
  }
  .circle-back:hover {
    background: var(--color-primary);
  }

  .anime-mini-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  .mini-title {
    font-weight: 700;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .mini-status {
    font-size: 0.7rem;
    color: var(--color-primary);
    font-weight: 800;
    text-transform: uppercase;
  }

  .nav-actions {
    display: flex;
    gap: 0.5rem;
  }
  .icon-btn {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    cursor: pointer;
    transition: 0.2s;
  }
  .icon-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }
  #fav-icon.active {
    fill: #f43f5e;
    color: #f43f5e;
  }

  /* PLAYER */
  .main-player-section {
    background: #000;
    padding-top: 60px; /* Reduced for mobile */
  }

  @media (min-width: 768px) {
    .main-player-section {
      padding-top: 80px;
    }
  }

  .player-viewport {
    width: 100%;
    aspect-ratio: 16/9;
    max-width: 1200px;
    margin: 0 auto;
    position: relative;
    background: #000;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }
  .stream-iframe {
    width: 100%;
    height: 100%;
    border: none;
  }

  .player-overlay {
    position: absolute;
    inset: 0;
    background: #000;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 1rem;
  }
  .vylos-loader {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(59, 130, 246, 0.1);
    border-top-color: var(--color-primary);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .player-toolbar {
    max-width: 1200px;
    margin: 0 auto;
    background: #0f172a;
    padding: 1rem;
    display: flex;
    flex-direction: column; /* Column by default on mobile */
    gap: 1rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  @media (min-width: 768px) {
    .player-toolbar {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.5rem;
    }
  }

  .toolbar-left {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  @media (min-width: 480px) {
    .toolbar-left {
      flex-direction: row;
      align-items: center;
      gap: 1.5rem;
    }
  }

  .lang-selector {
    display: flex;
    background: rgba(0, 0, 0, 0.3);
    padding: 4px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    width: fit-content;
  }
  .lang-btn {
    background: transparent;
    border: none;
    color: #64748b;
    padding: 6px 16px;
    font-size: 0.8rem;
    font-weight: 800;
    cursor: pointer;
    border-radius: 7px;
    transition: 0.2s;
  }
  .lang-btn.active {
    background: var(--color-primary);
    color: white;
  }

  .server-selector {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    overflow-x: auto;
    scrollbar-width: none;
    padding-bottom: 2px;
  }
  .server-selector::-webkit-scrollbar {
    display: none;
  }

  .toolbar-label {
    font-size: 0.65rem;
    font-weight: 800;
    color: #475569;
    text-transform: uppercase;
    white-space: nowrap;
  }
  .server-chips {
    display: flex;
    gap: 0.5rem;
  }
  .chip {
    background: #1e293b;
    color: #94a3b8;
    border: none;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 700;
    cursor: pointer;
    transition: 0.2s;
    white-space: nowrap;
  }
  .chip.active {
    background: rgba(59, 130, 246, 0.2);
    color: var(--color-primary);
    border: 1px solid var(--color-primary);
  }

  .action-btn {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #94a3b8;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    width: 100%; /* Full width on mobile */
  }

  @media (min-width: 768px) {
    .action-btn {
      width: auto;
    }
  }

  /* CONTENT */
  .stream-content {
    padding-top: 2rem;
    padding-bottom: 5rem;
  }
  .stream-layout {
    display: grid;
    grid-template-columns: 1fr;
    gap: 2rem;
  }

  @media (min-width: 1024px) {
    .stream-layout {
      grid-template-columns: 1fr 340px;
      gap: 3rem;
    }
  }

  .anime-title {
    font-size: 1.5rem;
    font-weight: 800;
    margin-bottom: 0.75rem;
    line-height: 1.2;
  }

  @media (min-width: 768px) {
    .anime-title {
      font-size: 2.25rem;
    }
  }

  .badges {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 2rem;
  }
  .badge {
    padding: 4px 10px;
    background: #1e293b;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 700;
    color: #cbd5e1;
  }
  .score {
    color: #fbbf24;
    background: rgba(251, 191, 36, 0.1);
  }

  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.25rem;
  }
  .section-title {
    font-size: 1rem;
    font-weight: 800;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .progress-badge {
    font-size: 0.7rem;
    color: var(--color-text-muted);
    font-weight: 600;
  }

  .ep-selector-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(42px, 1fr));
    gap: 8px;
    margin-bottom: 2.5rem;
  }

  @media (min-width: 768px) {
    .ep-selector-grid {
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 10px;
    }
  }

  .ep-chip {
    aspect-ratio: 1;
    background: #1e293b;
    border: 1px solid rgba(255, 255, 255, 0.05);
    color: white;
    border-radius: 8px;
    font-weight: 800;
    cursor: pointer;
    transition: 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.85rem;
  }
  .ep-chip:hover {
    border-color: var(--color-primary);
    transform: translateY(-2px);
  }
  .ep-chip.active {
    background: var(--color-primary);
    border-color: var(--color-primary);
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }
  .ep-chip.watched {
    border-color: rgba(59, 130, 246, 0.3);
    color: #94a3b8;
  }
  .ep-chip.watched:not(.active) {
    background: rgba(30, 41, 59, 0.6);
  }

  .description {
    color: #94a3b8;
    line-height: 1.6;
    font-size: 0.95rem;
    margin-bottom: 2.5rem;
  }
  .error-box {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.2);
    color: #f87171;
    padding: 1.25rem;
    border-radius: 12px;
    display: flex;
    align-items: center;
    gap: 1rem;
    font-size: 0.9rem;
  }

  .seasons-stack {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }
  .season-link {
    display: flex;
    gap: 1rem;
    text-decoration: none;
    background: #0f172a;
    padding: 0.75rem;
    border-radius: 12px;
    border: 1px solid transparent;
    transition: 0.2s;
  }
  .season-link:hover {
    border-color: var(--color-primary);
    background: #1e293b;
  }
  .season-link img {
    width: 50px;
    height: 75px;
    object-fit: cover;
    border-radius: 6px;
  }
  .rel-tag {
    font-size: 0.6rem;
    color: var(--color-primary);
    font-weight: 800;
    text-transform: uppercase;
    margin-bottom: 2px;
    display: block;
  }
  .rel-name {
    font-size: 0.9rem;
    color: white;
    font-weight: 600;
    line-height: 1.3;
  }
</style>
